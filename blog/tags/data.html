<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">&quot;data&quot; 태그로 연결된 4개 게시물개의 게시물이 있습니다. | 데이터 기반 쉐어링</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://leetaehwan.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://leetaehwan.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://leetaehwan.github.io/blog/tags/data"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="&quot;data&quot; 태그로 연결된 4개 게시물개의 게시물이 있습니다. | 데이터 기반 쉐어링"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://leetaehwan.github.io/blog/tags/data"><link data-rh="true" rel="alternate" href="https://leetaehwan.github.io/blog/tags/data" hreflang="ko"><link data-rh="true" rel="alternate" href="https://leetaehwan.github.io/blog/tags/data" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="데이터 기반 쉐어링 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="데이터 기반 쉐어링 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.1c022e41.css">
<script src="/assets/js/runtime~main.f92314ad.js" defer="defer"></script>
<script src="/assets/js/main.9d8fcfbb.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">데이터 기반 쉐어링</b></a><a class="navbar__item navbar__link" href="/docs/intro">Portfolio</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/blog/tags/eda">EDA</a><a class="navbar__item navbar__link" href="/blog/tags/ai">AI</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/tags/data">Data</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/supabase_tutorial_practice">Supabase란 무엇인가? 웹페이지 SELECT, INSERT 실습</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/features_collection">폴리움의 key_on 파라미터와 GeoJson 및 GeoData 이해하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/bean-scope">파이토치를 이용한 데이터셋 분리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/pytorch-dataset-split">파이토치를 이용한 데이터셋 분리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/spring-boot-dev-basic">스프링 부트 개발의 기초 상식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><header class="margin-bottom--xl"><h1>&quot;data&quot; 태그로 연결된 4개 게시물개의 게시물이 있습니다.</h1><a href="/blog/tags">모든 태그 보기</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Supabase란 무엇인가? 웹페이지 SELECT, INSERT 실습"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/supabase_tutorial_practice">Supabase란 무엇인가? 웹페이지 SELECT, INSERT 실습</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-01-16T00:00:00.000Z" itemprop="datePublished">2024년 1월 16일</time> · <!-- -->약 9분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/leetaehwan.png" alt="이태환" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이태환</span></a></div><small class="avatar__subtitle" itemprop="description">개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="supabase란-무엇인가-웹페이지-select-insert-실습">Supabase란 무엇인가? 웹페이지 SELECT, INSERT 실습</h2>
<h3 id="목적">목적</h3>
<ul>
<li>Supabase란 무엇인가?<!-- -->
<ul>
<li>Firebase와의 차이점은 무엇인가?</li>
</ul>
</li>
<li>웹페이지에서 데이터를 불러오고 삽입하기<!-- -->
<ul>
<li>구현하고자 하는 코드</li>
<li>발생한 문제</li>
</ul>
</li>
</ul>
<h2 id="생활코딩의-supabase-입문수업---youtube를-실습했습니다">생활코딩의 <a href="https://www.youtube.com/watch?v=FbLzqoENTsg">Supabase 입문수업 - YouTube</a>를 실습했습니다.</h2>
<ul>
<li>부딪혔던 문제와 해결법을 공유합니다.</li>
</ul>
<h2 id="supabase란-무  엇인가">Supabase란 무엇인가?</h2>
<ul>
<li>웹과 앱의 백앤드를 구현하기 위한 모든 기능을 제공하는 클라우드 서비스</li>
<li>데이터베이스 : 데이터가 모여져 있는 공간으로 구조적인 방식으로 관리되는 데이터들의 집합</li>
<li>스토리지 : 업로드된 파일을 저장</li>
<li>인증기능 : 회원가입 및 로그인, 로그아웃 등</li>
<li>Edge Function : 프로그래밍적으로 다양한 기능 처리 (장고, FastAPI 등이 수행하던)</li>
</ul>
<h3 id="구글의-firebase와의-차이점">구글의 Firebase와의 차이점</h3>
<ul>
<li>Supabase는 데이터베이스를 관계형 데이터베이스인 PostgreSQL을 사용합니다.</li>
</ul>
<h2 id="supabase의-계층">Supabase의 계층</h2>
<p><img src="https://i.imgur.com/VZY2ILh.png" alt=""></p>
<ol>
<li>계정 (Account)</li>
<li>조직 (Organizations)</li>
<li>프로젝트 (Projects)<!-- -->
<ul>
<li>데이터베이스</li>
<li>스토리지</li>
<li>인증기능</li>
<li>Edge functions</li>
</ul>
</li>
</ol>
<h2 id="실습에서-만들고자-하는-서비스">실습에서 만들고자 하는 서비스</h2>
<ul>
<li>슈파베이스를 통해 데이터베이스를 구축한다.<!-- -->
<ul>
<li>title(text), body(text), create_at(date), id(int8) 컬럼을 만든다.</li>
</ul>
</li>
<li>웹페이지를 통해 구축된 데이터베이스에서 불러와 렌더링한다.</li>
<li>웹페이지의 &#x27;Create&#x27; 버튼을 이용해서 새로운 &#x27;title&#x27;과 &#x27;body&#x27;를 입력받아 데이터베이스로 신규 데이터로 추가한다.</li>
</ul>
<p><img src="https://i.imgur.com/OjScxnD.png" alt=""></p>
<h3 id="1-supabase-가입하기">1. Supabase 가입하기</h3>
<p><img src="https://i.imgur.com/eefXkLv.png" alt=""></p>
<ul>
<li>
<p>웹페이지에 들어가면, 나오는 대문 내용이 아주 맘에든다.</p>
<ul>
<li>일주일안에 만들어서, 수백만에게 배포하기</li>
</ul>
</li>
<li>
<p>회원가입을 해보자.
<img src="https://i.imgur.com/BDrXTjX.png" alt=""></p>
</li>
<li>
<p>나는 GitHub으로 회원가입했다.</p>
</li>
</ul>
<h3 id="2-프로젝트-만들기">2. 프로젝트 만들기</h3>
<p><img src="https://i.imgur.com/BBHoA3p.png" alt=""></p>
<ul>
<li>프로젝트를 시작하기 위해서 &#x27;Start your project&#x27; 버튼을 눌러보자.</li>
<li>그러면 아래와 같은 대쉬보드가 나타난다.</li>
</ul>
<p><img src="https://i.imgur.com/cQ2iBwd.png" alt=""></p>
<ul>
<li>이름을 사용한 기본값 조직이 생성되어 있을 것이다. 이 조직 안에 &#x27;New Project&#x27; 버튼을 눌러보자.</li>
</ul>
<p><img src="https://i.imgur.com/Mn8vMqw.png" alt=""></p>
<ul>
<li>프로젝트 상위 조직을 지정한다.</li>
<li>프로젝트 이름을 정하고</li>
<li>PostgreSQL의 데이터베이스의 암호를 입력한다.<!-- -->
<ul>
<li>나는 생성기를 통해서 생성했다. (따로 저장해두고 사용할 일을 거의 없다고 한다.)</li>
</ul>
</li>
<li>Region은 서비스가 배포될 지역과 가까운 곳으로 설정하자.<!-- -->
<ul>
<li>나는 한국에 서비스를 해야하니, 서울로 정한다.</li>
</ul>
</li>
<li>위 내용들을 설정하면 이제 프로젝트가 만들어졌다.</li>
</ul>
<h3 id="3-데이터-입력하기">3. 데이터 입력하기</h3>
<p><img src="https://i.imgur.com/cjHpJ8u.png" alt=""></p>
<ul>
<li>프로젝트 생성을 마치면, 위와 같이 대쉬보드가 보입니다.</li>
<li>테이블 데이터를 만들어주기 위해서 &#x27;테이블 에디터&#x27; 버튼을 눌러줍니다.</li>
</ul>
<p><img src="https://i.imgur.com/8p95VR0.png" alt=""></p>
<ul>
<li>&#x27;New table&#x27; 버튼을 눌러 새 테이블을 만듭시다.</li>
</ul>
<p><img src="https://i.imgur.com/3ZZnWex.png" alt=""></p>
<ul>
<li>기본값으로는 &#x27;RLS&#x27;가 활성화 되어있다.</li>
</ul>
<p><img src="https://i.imgur.com/hlzJLYv.png" alt=""></p>
<ul>
<li>처음에 RLS를 체크를 해제하고 아래와 같이 &#x27;page&#x27; 테이블을 만들었  다.</li>
</ul>
<p><img src="https://i.imgur.com/bGBVF2L.png" alt=""></p>
<ul>
<li>이렇게 만든 테이블은 누구나에게 접근이 가능하게 된다고 경고가 나온다.<!-- -->
<ul>
<li>RLS을 활성화 하지 않아서 그렇다.</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/gvv9342.png" alt=""></p>
<ul>
<li>&#x27;Insert&#x27; 버튼을 누르고, &#x27;Insert row&#x27;를 눌러 데이터를 추가해보자.</li>
</ul>
<p><img src="https://i.imgur.com/kpDXNDl.png" alt=""></p>
<ul>
<li>&#x27;id&#x27;와 &#x27;create_at&#x27;은 자동으로 입력된다.</li>
<li>선택 영역인 &#x27;title&#x27;과 &#x27;body&#x27;를 예시로 입력하고 저장해보자.</li>
</ul>
<p><img src="https://i.imgur.com/7FQrdn0.png" alt=""></p>
<ul>
<li>&#x27;id&#x27;값이 1인 데이터가 하나 만들어졌다.</li>
</ul>
<h3 id="4-웹서비스와-연결하기">4. 웹서비스와 연결하기</h3>
<ul>
<li>웹페이지와 데이터베이스를 연결한 서비스를 만든다고 가정해보자.</li>
<li>완성된 예시 코드를 먼저 훑어보자.</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2&quot;&gt;&lt;/script&gt;
    &lt;title&gt;JS Bin&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Supatodo&lt;/h1&gt;
    &lt;div id=&quot;history&quot;&gt;&lt;/div&gt;
    &lt;input type=&quot;button&quot; value=&quot;create&quot; id=&quot;create_btn&quot; /&gt;

    &lt;script&gt;
      const supabaseUrl = API의 url
      const supabaseKey = API의 key
      const client = supabase.createClient(supabaseUrl, supabaseKey)
        async function refreshHistory() {
        let { data: record, error } = await client.from(&#x27;page&#x27;).select(&#x27;*&#x27;);
        console.log(&#x27;record&#x27;, record);
        let tag = &quot;&quot;;
        for (let i = 0; i &lt; record.length; i++) {
          tag += `&lt;h2&gt;${record[i].title}&lt;/h2&gt;${record[i].body}`;
        }
        document.querySelector(&#x27;#history&#x27;).innerHTML = tag;
        }
      refreshHistory()

      async function recordHandler() {
        const { data, error } = await client
      .from(&#x27;page&#x27;)
      .insert([
        { title: prompt(&quot;title?&quot;), body: prompt(&quot;body?&quot;) }
      ]).select()
        refreshHistory()
      }
      document.querySelector(&#x27;#create_btn&#x27;).addEventListener(&quot;click&quot;, recordHandler);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="4-1-웹페이지에-supabase-설치">4-1. 웹페이지에 supabase 설치</h4>
<ul>
<li>supabase의 도큐먼트 -&gt; <a href="https://supabase.com/docs/reference/javascript/installing">Installing</a>을 보면 &#x27;package&#x27; 또는 &#x27;CDN&#x27;을 통한 설치 안내가 나와있다.</li>
<li>여기서는 CDN으로 supabase를 설치한다.</li>
</ul>
<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2&quot;&gt;&lt;/script&gt;
//or
&lt;script src=&quot;https://unpkg.com/@supabase/supabase-js@2&quot;&gt;&lt;/script&gt;
</code></pre>
<h4 id="4-2-supabase-api-연결하기">4-2. supabase API 연결하기</h4>
<p><img src="https://i.imgur.com/IkZn2Rd.png" alt=""></p>
<ul>
<li>&#x27;API 문서&#x27; 탭을 들어가면, &#x27;Introduction&#x27; 영역에서 우리가 API를 연결할 수 있는 코드가 제공된다.</li>
<li>웹페이지에서 패키지를 import하는 것이 까다롭기 때문에, 여기서는 사용하지 않는다.<!-- -->
<ul>
<li>대신에 CDN으로 설치하면 전역변수 supabase를 통해 기능을 접근할 수 있다.</li>
</ul>
</li>
<li>&#x27;url&#x27;과 &#x27;key&#x27;가 입력되어야 한다.</li>
</ul>
<p><img src="https://i.imgur.com/HiRJ0JG.png" alt=""></p>
<ul>
<li>이는 &#x27;설정 -&gt; API&#x27;에 들어가면 볼 수 있다.</li>
</ul>
<h4 id="4-3-테이블에서-데이터를-읽어오기">4-3. 테이블에서 데이터를 읽어오기</h4>
<p><img src="https://i.imgur.com/Vf3G1ne.png" alt=""></p>
<ul>
<li>&#x27;Introduction&#x27; 항목 밑에 우리가 만든 테이블 이름을 고를 수 있다.</li>
<li>밑으로 스크롤을 좀 내리면 &#x27;Read rows&#x27; 영역에 &#x27;READ ALL ROWS&#x27;의 코드가 있다.</li>
<li>이 비동기(await) 코드를 async 함수에 넣어서 사용해주면 데이터를 불러와 콘솔에 출력시켜볼 수 있다.</li>
</ul>
<pre><code class="language-js">async function refreshHistory() {
    let { data: record, error } = await client.from(&#x27;page&#x27;).select(&#x27;*&#x27;);
    console.log(&#x27;record&#x27;, record);
</code></pre>
<h4 id="4-4-웹페이지-div-태그에-불러온-데이터-삽입하기">4-4. 웹페이지 div 태그에 불러온 데이터 삽입하기</h4>
<ul>
<li>데이터를 읽은 수 만큼 할당하는 동적할당을 위해서 for문을 사용한다.<!-- -->
<ul>
<li>for문으로 record를 반복해서 title과 body를 문자열 tag에 담아준다.</li>
<li>완성된 tag를 querySelector()를 통해서 div를 선택햬서, innerHTML에 넣어준다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">let tag = &quot;&quot;;
for (let i = 0; i &lt; record.length; i++) {
  tag += `&lt;h2&gt;${record[i].title}&lt;/h2&gt;${record[i].body}`;
}
document.querySelector(&quot;#history&quot;).innerHTML = tag;
</code></pre>
<h4 id="4-5-웹페이지에-create-버튼으로-데이터베이스에-데이터-추가하기">4-5 웹페이지에 &#x27;create&#x27; 버튼으로 데이터베이스에 데이터 추가하기</h4>
<ul>
<li>아까 읽어온 것처럼 &#x27;API 문서&#x27;의 테이블에 들어가서 &#x27;INSERT A ROW&#x27;의 코드를 가져온다.
<img src="https://i.imgur.com/O64exzD.png" alt=""></li>
<li>위 코드를 가져와서 async 함수에 넣어준다.</li>
<li>위에서 some_column과 other_column에 우리가 넣고자 하는 데이터베이스의 컬럼 값을 넣어준다.</li>
<li>그리고 &#x27;someValue&#x27;와 &#x27;otherValue&#x27;에 넣고자 하는 값을 넣어준다.<!-- -->
<ul>
<li>여기서는 prompt를 입력받아서 데이터를 삽입해주고 페이지에 랜더링한다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">async function recordHandler() {
  const { data, error } = await client
    .from(&quot;page&quot;)
    .insert([{ title: prompt(&quot;title?&quot;), body: prompt(&quot;body?&quot;) }])
    .select();
  refreshHistory();
}
document.querySelector(&quot;#create_btn&quot;).addEventListener(&quot;click&quot;, recordHandler);
</code></pre>
<ul>
<li>여기까지 supabase 입문에 대해 알아보는 것을 마친다.</li>
</ul>
<h3 id="결론">결론</h3>
<ul>
<li>supabase를 가입</li>
<li>프로젝트를 만들고</li>
<li>table을 만들어 웹페이지에서 불러와(SELECT) 랜더링</li>
<li>웹페이지에서 table의 데이터를 삽입(INSERT)</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/supabase">supabase</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/postgre-sql">postgreSQL</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/insert">insert</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/select">select</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/firebase">firebase</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/data">data</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="폴리움으로 등차지역도 그리기"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/features_collection">폴리움의 key_on 파라미터와 GeoJson 및 GeoData 이해하기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-08-20T00:00:00.000Z" itemprop="datePublished">2023년 8월 20일</time> · <!-- -->약 4분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/leetaehwan.png" alt="이태환" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이태환</span></a></div><small class="avatar__subtitle" itemprop="description">개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="폴리움으로-등차지역도-그리기">폴리움으로 등차지역도 그리기</h2>
<p>folium.Choropleth() 메서드를 이용해서 등차지역도를 그릴 수 있다.
<a href="http://data.seoul.go.kr/dataList/OA-1180/F/1/datasetView.do">서울시 개별공시지가 정보</a>의 데이터를 활용하면, 동별 평균 공시지가를 구할 수 있고,
지정된 데이터의 법정동 이름과 공시지가의 컬럼을 가지고 데이터 만들고, 법정동 명을 키로 해서 지도에 시각화 시키고자 한다.</p>
<p><img src="/assets/images/1_folium_choropleth-f844e60bff6b176fdef2bff4b491da7a.png" width="688" height="312"></p>
<p>key_on의 파라미터의 인수로서 geo_data의 컬럼을 지정하는 지 않고, JSON의 형식처럼 &quot;feature.propertiees.bj_nm&quot;을 넣어주었다.</p>
<p>geo_data는 어떻게 생겼길래 이렇게 넣어주는 것인가?</p>
<h2 id="geo_data는-어떤-녀석인가">Geo_data는 어떤 녀석인가?</h2>
<p>여기에서 나오는 sungdong_gu_dong_gpd는 GeoDataFrame이다.</p>
<pre><code class="language-python">sungdong_gu_dong_gpd.info()
</code></pre>
<p>를 출력해보자. GeoDataFrame이라고 한다. 컬럼들을 갖는게 데이터프레임과 비슷해보인다.</p>
<p><img src="/assets/images/2_sungdong_gu_dong_gpd-b9dc6c55367a15b76bcc32b2ae004c82.png" width="872" height="564"></p>
<pre><code class="language-python">sungdong_gu_dong_gpd.head()
</code></pre>
<p>를 출력해보자. 여전히 데이터 프레임과 같아 보인다.</p>
<p><img src="/assets/images/3_sungdong_gu_dong_gpd-68fb83e49f2195a27c255c9f67e66741.png" width="1556" height="368"></p>
<pre><code class="language-python">sungdong_gu_dong_gpd.to_json()
</code></pre>
<p> 으로 JSON 형식으로 바꿔보자.</p>
<p><img src="/assets/images/4_sungdong_gu_dong_gpd-403611afb9552a40b05aa6a85f7414bd.png" width="1740" height="192">
한 줄로 나와서 보기가 불편하다.</p>
<pre><code class="language-python">sungdong_gu_dong_gpd.__geo_interface__
</code></pre>
<p>으로 출력하니 보기가 좋다.</p>
<p><img src="/assets/images/5_sungdong_gu_dong_gpd-f3a065f9148ad6a955f715309183340a.png" width="570" height="1432"></p>
<p>우리가 찾는 구조의 json형식의 파일이 나온다. 그럼 JSON 자료형인가? <code>__geo_interface__</code> 에 대해서 알아보자.</p>
<h2 id="__geo_interface__이란-무엇인가"><code>__geo_interface__</code>이란 무엇인가?</h2>
<p><code>GeoDataFrame.__geo_interface__</code> 메서드는 GeoDataFrame을 파이썬의 GeoJSON 같은 FeaturesCollection의 형식으로 반환한다.</p>
<h2 id="foliumchoroplethkey_on-파라미터는-무엇인가">folium.choropleth(key_on) 파라미터는 무엇인가?</h2>
<p><code>folium.Choropleth()</code>는 컬러 그레디언트를 사용해서 맵에 데이터를 시각화 하기 위해 사용하는 메서드이다.
메서드의 한 파라미터가 <code>key_on</code>이다. 이 파라미터는 다른 파라미터로 제공된 <code>data</code>와 매칭되어 사용되어질 GeoJSON 데이터의 property를 가리킨다.</p>
<p>위 코드에서 사용한 <code>key_on=feature.properties.bj_nm</code>을 쪼개서 이해해보면</p>
<ul>
<li>feature : folium이 GeoJSON을 구성하고 있는 feature 레벨 데이터에 접근하도록 말해준다.</li>
<li>properties : feature와 함께 많이 쓰게 되는 <code>properties</code>는 GeoJSON Feature들로 묶여 저장된 데이터들을 말하며 <code>&lt;GeoJSON_object&gt;</code>의 하나이다.</li>
<li>bj_nm : <code>properties</code>로 묶여진 특정 속성의 이름이다.</li>
</ul>
<h2 id="요약">요약</h2>
<ul>
<li>foilum.choropleth()는 geoData와 DataFrame을 연결하여 시각화 한다.</li>
<li>이때, DataFrame은 컬럼, GeoData는 GeoJSON의 property들을 매칭하여 시각화 한다.</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/folium">folium</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/choropleth">Choropleth</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/geo-interface">__geo_interface__</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/geo-json">GeoJSON</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/key-on">key_on</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/data">data</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="- 애플리케이션이 어떻게 동작하는지"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/spring-boot-dev-basic">스프링 부트 개발의 기초 상식</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-25T00:00:00.000Z" itemprop="datePublished">2023년 3월 25일</time> · <!-- -->약 12분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/leetaehwan.png" alt="이태환" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이태환</span></a></div><small class="avatar__subtitle" itemprop="description">개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><ul>
<li>애플리케이션이 어떻게 동작하는지</li>
<li>어떠한 이유로 이러한 구성을 갖게 되는지</li>
<li>위에 관한 점들을 알고 실습하기 위한 기초지식</li>
</ul>
<h1 id="서버-간-통신">서버 간 통신</h1>
<ul>
<li>서버 간 통신은 한 서버에서 다른 서버로 요청하는 것을 의미하는 단어로</li>
<li>통신을 요청하는 클라이언트와 응답을 내려주는 서버 간의 통신을 이야기한다.</li>
<li>가장 흔한 프로토콜이 HTTP/HTTPS 방식이다.</li>
</ul>
<h2 id="마이크로서비스-아키텍처에서-더-많이-활용된다">마이크로서비스 아키텍처에서 더 많이 활용된다.</h2>
<ul>
<li>단일 애플리케이션으로 다양한 서비스를 하면 유지보수에 따른 비용이 크다.</li>
<li>따라서, 요즘에는 여러 애플리케이션을 서비스별로 나눠서 개발한다.</li>
<li>하지만 이때문에 각자의 독립적인 애플리케이션 서버간의 통신이 잦아진다.</li>
</ul>
<h1 id="스프링-부트-동작-방식">스프링 부트 동작 방식</h1>
<ul>
<li>스프링 부트에서는 기본적으로 톰캣을 사용하는 스프링 MVC 구조를 기반으로 동작한다.
<img src="/assets/images/dispatching-servlet-2d1d65483391b0f750b5826bea51750c.png" width="1770" height="814"></li>
</ul>
<h2 id="서블릿">서블릿</h2>
<ul>
<li>서블릿은 클라이언트의 요청을 처리하고 결과를 반환하는 웹프로그래밍 기술이다.</li>
<li>서블릿 컨테이너가 서블릿 인스턴스를 생성하고 관리한다.</li>
</ul>
<h2 id="스프링에서-서블릿">스프링에서 서블릿</h2>
<ul>
<li>스프링에서는 발송 서블렛이 웹 애플리케이션으로 들어오는 모든 요청을 중앙제어하는 프론트 컨트롤러를 구현한다.</li>
<li>발송 서블릿이 들어오는 요청을 받아서 적절한 핸들러에 전달한다.</li>
<li>발송 서블릿이 많은 핸 들러 매핑을 사용하여, 각각의 요청을 어떤 핸들러가 처리해야하는지 결정한다.</li>
<li>스픵은임베딩된 톰캣을 내장서버로서 사용하기 때문에, 서블렛, 필터와 애플리케이션을 구성하는 웹 컴포넌트들의 환경설정을 web.xml에 적는다.</li>
<li>즉, web.xml 파일안에 정의된 URL 매핑을 기반으로 적절한 서블릿과 필터로 요청을 보낸다.</li>
</ul>
<h2 id="스프링-부트의-동작-순서">스프링 부트의 동작 순서</h2>
<ol>
<li>발송 서블렛으로 HttpServletRequest의 요청이 들어오면, 요청받은 URL에 매핑된 핸들러 컨트롤러를 탐색한다.</li>
<li>핸들러 어댑터로 컨트롤러가 호출된다.</li>
<li>핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndVew로 응답을 가공해 반환한다.</li>
<li>뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버가 뷰를 반환한다.</li>
</ol>
<h2 id="핸들러-매핑">핸들러 매핑</h2>
<ul>
<li>핸들러 매핑 인터페이스는 요청 정보를 기준으로 어떤 컨트롤러를 사용할 것인가 결정한다.</li>
</ul>
<h2 id="핸들러-매핑의-구현체-클래스">핸들러 매핑의 구현체 클래스</h2>
<h3 id="beannameurlhandlermapping">BeanNameUrlHandlerMapping</h3>
<ul>
<li>기본설정값의 핸들러 매핑 구현체로</li>
<li>빈의 이름을 요청 URL과 매핑하는데 사용한다.</li>
<li>빈을 정의하면서, 슬래시(/)와 함께 작성된 식별자인 슬러그를 지정하여 매핑한다.</li>
</ul>
<pre><code>@Bean(&quot;/hello&quot;)
</code></pre>
<ul>
<li>
<p>&#x27;/hello&#x27;라는 슬러그에 빈이 매핑되었다.</p>
</li>
<li>
<p>이러한 매핑은 직접적인 이름 매칭과 &quot;*&quot;패턴을 사용하는 패턴 매칭을 돕는다.</p>
</li>
<li>
<p>수신된 URL &quot;/foo&quot;가 &#x27;/foo&#x27;라고 불리는 빈에 매핑된다.</p>
</li>
<li>
<p>패턴 매핑은 &quot;/foo&quot; 요청을 &#x27;/foo&#x27;, &#x27;/foo2&#x27;, &#x27;/fooOne&#x27; 등으로 매칭한다.</p>
</li>
<li>
<p>아래는 &#x27;/beanNameUrl&#x27; 요청을 다루는 빈 컨트롤러를 등록하는 소스코드이다.</p>
</li>
</ul>
<pre><code>@Configuration
public class BeanNameUrlHandlerMappingConfig {
    @Bean
    BeanNameUrlHandlerMapping beanNameUrlHandlerMapping() {
        return new BeanNameUrlHandlerMapping();
    }

    @Bean(&quot;/beanNameUrl&quot;)
    public WelcomeController welcome() {
        return new WelcomeController();
    }
}
</code></pre>
<ul>
<li>이것이 위의 자바 기반 환경 구성과 같은 xml 코드이다.</li>
</ul>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot; /&gt;
&lt;bean name=&quot;/beanNameUrl&quot; class=&quot;com.baeldung.WelcomeController&quot; /&gt;

</code></pre>
<ul>
<li>이러한 환경설정 둘 다, BeanNameUrlHandlerMapping에 관한 빈을 정의하는 것이 필수가 아니다.</li>
<li>스프링 MVC에서 다 제공된다.</li>
<li>빈 정의를 지우는 것이 문제를 발생시키지 않기에, 요청들이 등록된 핸들러 빈에 여전히 매핑될 것이다.</li>
<li>&#x27;/beanNameUrl&#x27;의 모든 요청이 발송 서블릿에 의해서 &#x27;WelcomeController&#x27;로 보내진다.</li>
<li>그러면 &#x27;WelcomeController&#x27;는 &#x27;welcome&#x27;이라는 뷰를 반환한다.</li>
<li>아래의 코드를 통해 환경설정을 테스트하고 올바른 뷰 이름을 반환하는지 확인하자.</li>
</ul>
<pre><code>public class BeanNameMappingConfigTest {
    // ...

    @Test
    public void whenBeanNameMapping_thenMappedOK() {
        mockMvc.perform(get(&quot;/beanNameUrl&quot;))
          .andExpect(status().isOk())
          .andExpect(view().name(&quot;welcome&quot;));
    }
}
</code></pre>
<h3 id="simpleurlhandlermapping">SimpleUrlHandlerMapping</h3>
<ul>
<li>SimpleUrlHandlerMapping은 좀 더 유연한 핸들러 매핑 구현체이다.</li>
<li>이 매핑은 빈 객체와 URL 간 또는 빈 이름과 URL 간의 직접적이고 선언적인 매핑이다.</li>
<li>&quot;/simpleUrlWelcome&quot;과 &quot;/*/simpleUrlWelcome&quot; 요청을 &#x27;welcome&#x27; 빈으로 매핑해보자.</li>
</ul>
<pre><code>@Configuration
public class SimpleUrlHandlerMappingConfig {

    @Bean
    public SimpleUrlHandlerMapping simpleUrlHandlerMapping() {
        SimpleUrlHandlerMapping simpleUrlHandlerMapping
          = new SimpleUrlHandlerMapping();
        
        Map&lt;String, Object&gt; urlMap = new HashMap&lt;&gt;();
        urlMap.put(&quot;/simpleUrlWelcome&quot;, welcome());
        simpleUrlHandlerMapping.setUrlMap(urlMap);
        
        return simpleUrlHandlerMapping;
    }

    @Bean
    public WelcomeController welcome() {
        return new WelcomeController();
    }
}
</code></pre>
<ul>
<li>XML 환경설정에서도 아래와 같이 똑같이 설정할 수 있다.</li>
</ul>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;value&gt;
            /simpleUrlWelcome=welcome
            /*/simpleUrlWelcome=welcome
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;welcome&quot; class=&quot;com.baeldung.WelcomeController&quot; /&gt;
</code></pre>
<ul>
<li>
<p>XML 환경설정을 다음과 같은 것들이 중요하다. java.util.Properties 클래스에 의해 받아지는 폼에서 &lt; value &gt; 태그 사이의 매핑이 이루어진다.</p>
</li>
<li>
<p>매핑을 할 때는 path = Handler_Bean_Name 의 규칙을 따른다.</p>
</li>
<li>
<p>URL이 보통 리딩 슬래시와 함께 작성되지만, 경로가 하나로 시작하는 게 아니라면 스프링 MVC는 자동으로 추가해준다.</p>
</li>
<li>
<p>XML에 위의 예를 설정하는 다른 방법은 &#x27;props&#x27; 속성을 &#x27;value&#x27; 속성을 대신해 사용하는 것이다.</p>
</li>
<li>
<p>Props은 prop태그의 리스트를 가진다.</p>
</li>
<li>
<p>prop태그를 통해서 매핑하는데, &#x27;key&#x27;가 매핑된 URL을 참조하고 태그의 값이 빈의 이름이다.</p>
</li>
</ul>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;/simpleUrlWelcome&quot;&gt;welcome&lt;/prop&gt;
            &lt;prop key=&quot;/*/simpleUrlWelcome&quot;&gt;welcome&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>아래 테스트 코드가 &quot;/simpleUrlWelcome&quot; 요청이 &#x27;welcome&#x27; 뷰를 반환하는 &#x27;WelcomeController&#x27;에 의해 핸들되는지 확인한다.</li>
</ul>
<pre><code>public class SimpleUrlMappingConfigTest {
    // ...

    @Test
    public void whenSimpleUrlMapping_thenMappedOK() {
        mockMvc.perform(get(&quot;/simpleUrlWelcome&quot;))
          .andExpect(status().isOk())
          .andExpect(view().name(&quot;welcome&quot;));
    }
}
</code></pre>
<h3 id="controllerclassnamehandlermapping">ControllerClassNameHandlerMapping</h3>
<ul>
<li>
<p>URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용한다.</p>
</li>
<li>
<p>ControllerClassNameHandlerMapping은 URL을 등록된 컨드롤러 빈(@Controller 주석이 언급된 컨트롤러)에 매핑한다.</p>
</li>
<li>
<p>컨트롤러의 이름은 같은 이름을 가지거나 그 이름으로 시작한다.</p>
</li>
<li>
<p>많은 경우에서 더 편리할 수 있는데, 특히 하나의 요청 형을 핸들링하는 단순한 컨트롤러 구현체에 경우 더욱 편리하다.</p>
</li>
<li>
<p>스프링 MVC에서 사용하는 규칙은 이름에서 Controller를 제외하고 접미사를 소문자로 &quot;/&quot;을 붙여서 매핑한다.</p>
</li>
<li>
<p>&quot;WelcomeController&quot;는 &quot;/welcome*&quot;을 매핑한다. 즉, &quot;welcome&quot;으로 시작하는 어떠한 URL이 매핑된다.</p>
</li>
</ul>
<pre><code>@Configuration
public class ControllerClassNameHandlerMappingConfig {

    @Bean
    public ControllerClassNameHandlerMapping controllerClassNameHandlerMapping() {
        return new ControllerClassNameHandlerMapping();
    }

    @Bean
    public WelcomeController welcome() {
        return new WelcomeController();
    }
}
</code></pre>
<ul>
<li>ControllerClassNameHandlerMapping이 스프링 4.3에서 사라지게되었다. 주석 주도 핸들러 방법이 선호되어지기 때문이다.</li>
<li>컨트롤러 이름이 항상 컨트롤러 접미사를 지우고 소문자로 반환한다는 것도 중요하다.</li>
<li>따라서 &#x27;/welcomTaehwan&#x27;은 요청에서 처리하지 못하고 &#x27;/welcometaehwan&#x27;의 요청만 처리할 수 있다.</li>
<li>자바와 아래의 XML 환경설정 모두에서, ControllerClassNameHandlerMapping 빈을 정의하고 요청을 처리할 때 사용할 컨트롤러에 빈을 등록한다.</li>
<li>&#x27;/welcome&#x27;으로 시작하는 요청을 핸들링하는 &quot;WelcomeControlle&quot;를 XML로 만들어보자.</li>
</ul>
<pre><code>@Configuration
public class ControllerClassNameHandlerMappingConfig {

    @Bean
    public ControllerClassNameHandlerMapping controllerClassNameHandlerMapping() {
        return new ControllerClassNameHandlerMapping();
    }

    @Bean
    public WelcomeController welcome() {
        return new WelcomeController();
    }
}
</code></pre>
<ul>
<li>위의 XML 환경설정을 사용하면, &#x27;/welcome&#x27;에 대한 요청이 &quot;WelcomeController&quot;에 의해서 핸들링된다.</li>
<li>아래 코드는 &quot;welcometest&quot;과 같은 &quot;/welcome*&quot; 요청이 &#x27;WelcomeController&#x27;에 의해서 핸들링이 되는지 테스트하고 welcome&#x27; 이름의 뷰를 반환하는지 확인한다.</li>
</ul>
<pre><code>public class ControllerClassNameHandlerMappingTest {
    // ...

    @Test
    public void whenControllerClassNameMapping_thenMappedOK() {
        mockMvc.perform(get(&quot;/welcometest&quot;))
          .andExpect(status().isOk())
          .andExpect(view().name(&quot;welcome&quot;));
    }
}
</code></pre>
<h3 id="defaultannotationhandlermapping">DefaultAnnotationHandlerMapping</h3>
<ul>
<li>어노테이션으로 URL과 컨트롤러를 매핑한다.</li>
<li>들어오는 HTTP 요청을 주석이 있는 컨트롤러 중에 적절한 것으로 보내준다.</li>
<li>요청이 들어오면, DefaultAnnotationHandlerMapping이 스프링 ApplicationContext에 등록된 모든 빈을 스캔해서 &#x27;@RequestMapping&#x27;, &#x27;@GetMapping&#x27;, &#x27;@PostMapping&#x27;이나 비슷한 어노테이션을 갖는 빈을 모두 찾는다.</li>
<li>그리고 이 정보를 활용해서 어떤 컨트롤러가 요청을 핸들링할 지 결정한다.</li>
<li>또한 DefaultAnnotationHandlerMapping은 매핑 처리의 동작을 커스터마이징하는 많은 어노테이션도 지원한다. (e.g. &#x27;@PathVariable&#x27;, &#x27;@RequestParam&#x27;, &#x27;@RequestBody&#x27;)</li>
<li>기본설정으로, DefaultAnnotationHandlerMapping이 스프링 MVC 구성에 포함되어 들어오는 HTTP 요을 핸들링하는데 사용된다.</li>
<li>하지만 필요하다면, 다른 매핑 전략으로 대체되거나 커스터마이징 될 수 있다.</li>
</ul>
<h1 id="refference">Refference</h1>
<ul>
<li><a href="https://www.baeldung.com/spring-handler-mappings">Baeldung</a></li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/data">data</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/spring-boot">spring-boot</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/contoller">contoller</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/handler-mapping">handler-mapping</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="- 백엔드를 배워본 적이 없는 학생이 김영한 스프링 부트 입문 강의를 듣고 작성한 글이다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/spring-boot-component-research">스프링 부트 구성요소 살펴보기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-23T00:00:00.000Z" itemprop="datePublished">2023년 3월 23일</time> · <!-- -->약 11분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/leetaehwan.png" alt="이태환" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이태환</span></a></div><small class="avatar__subtitle" itemprop="description">개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><ul>
<li>백엔드를 배워본 적이 없는 학생이 김영한 스프링 부트 입문 강의를 듣고 작성한 글이다.</li>
<li>스프링 부트를 통해서 손쉽게 스프링 프레임워크를 활용한 웹 어플리케이션 서버를 만든다.</li>
<li>클라이언트 사이드인 웹 브라우저가 보내는 요청을 내장 톰캣 서버를 통해 스프링 컨테이너에서 처리하여 반환 시킨다.</li>
</ul>
<h1 id="스프링-부트-구성요소-톺아보기">스프링 부트 구성요소 톺아보기</h1>
<h2 id="내장-톰캣-서버">내장 톰캣 서버</h2>
<ul>
<li>아파치 소프트웨어 재단에서 만든 WAS, 웹 어플리케이션이다.</li>
<li>자바 서블릿과 JSP, JavaServer Pages를 실행할 수 있는 환경을 제공한다.</li>
<li>Jakarta Servlet, Jakata Server Pages, Jakarta Expression Language 등의 사양을 구현한 오픈소스 소프트웨어이다.</li>
</ul>
<h3 id="아파치와-톰캣의-차이점">아파치와 톰캣의 차이점</h3>
<ul>
<li>아파치 소프트웨어 재단의 아파치 웹 서버이다.</li>
<li>정적 데이터인 HTML, CSS, 이미지 등을 처리하는데 빠르지만</li>
<li>톰캣은 WAS로서 JSP, 서블릿 처리, DB 연결 및 데이터 조작 등의 동적인 데이터를 처리하는데 적합하다.</li>
</ul>
<h2 id="정적--동적-데이터">정적 / 동적 데이터</h2>
<h3 id="정적-데이터">정적 데이터</h3>
<ul>
<li>사용자의 요청에 따라 변하지 않는 데이터이다.</li>
<li>HTML, CSS, 이미지 파일과 같은 데이터를 말하며, 정적인 데이터는 웹 서버를 통해서 처리된다.</li>
</ul>
<h3 id="동적-데이터">동적 데이터</h3>
<ul>
<li>사용자의 요청에 따라 변하는 데이터를 의미한다.</li>
<li>사용자가 입력한 정보를 바탕으로 DB에서 정보를 검색하거나 조작하여 반환되는 데이터들을 말한다.</li>
<li>이러한 동적 데이터는 WAS에서 처리된다.</li>
</ul>
<h2 id="웹-서버와-웹-어플리케이션-서버-was와의-차이점">웹 서버와 웹 어플리케이션 서버, WAS와의 차이점</h2>
<h1 id="스프링-컨테이너와-빈">스프링 컨테이너와 빈</h1>
<ul>
<li>스프링에서, 어플리케이션의 중추를 구성하는 객체와 스프링 Ioc 컨테이너에서 관리되는 객체들을 빈이라고 한다.</li>
<li>빈은 간단히 구체화된 객체로 스프링 IoC 컨테이너에 의해 조립되거나 관리되어진다.</li>
<li>이런 빈과 그것들 간의 의존관계가 컨테이너에서 사용하는 Configuration 메타데이터에 반영된다.</li>
</ul>
<h2 id="컨테이너">컨테이너</h2>
<h3 id="beanfactory">BeanFactory</h3>
<ul>
<li>org.springframework.beans.factory.BeanFactory는 스프링 IoC 컨테이너의 실체의 대표이다.</li>
<li>스프링 IoC 컨테이너는 앞서 언 급했던 빈들을 담거나 관리하는 책임이 있다.</li>
<li>BeanFractory 인터페이스는 스프링의 중심 IoC 컨테이너 인터페이스이다.</li>
<li>스프링으로 바로 제공되어지는 BeanFactory 인터페이스의다양한 구현들이 있다.</li>
<li>가장 많이 쓰이는 구현이 XmlBeanFactory 클래스이다.</li>
<li>이 구현은 우리가 앱을 구성하는 객체들과 의심할 여지없이 많은 객채들 간의 상호 의존관계를 XML의 언어로 표현하도록 한다.</li>
<li>XmlBeanFactory는 XML Configuration 메타데이터를 취해서 완전하게 환경설정된 시스템이나 앱을 만드는데 사용한다.</li>
</ul>
<p><img src="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/images/container-magic.png" alt="">
<a href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s02.html">4.2 Basics - containers and beans</a></p>
<h3 id="applicationcontext">ApplicationContext</h3>
<ul>
<li>ApplicationContext 인터페이스도 스프링 IoC 컨테이너를 대표하고 구현, 환경설정, 빈을 조합하는 역할을 수행한다.</li>
<li>BeanFactory의 대체 인터페이스로 더 많은 기업에 특화된 기능들을 제공한다.</li>
<li>제공되는 기능으로 메시지 확인(다국언어 지원), 이벤트 게시, 어플리케이션 레이어 특화 문맥이 있다.</li>
<li>어플리케이션 컴포넌트에 접근할 때 사용하는 ListableBeanFactory 메서드를 상속 받았고</li>
<li>일반적인 방법으로 파일 리스소를 읽는 기능을 ResourceLoader로부터 상속 받았다.</li>
<li>ApplicationEventPublisher로부터 상속받은 등록된 리스너들의 이벤트를 게시하는 능력도 가지고 있다.</li>
</ul>
<h2 id="컨트롤러란-무엇인가">컨트롤러란 무엇인가?</h2>
<ul>
<li>전형적인 MVC, Model-View-Controller 아키텍처에서 Controller의 개념을 들여다보자.</li>
</ul>
<h3 id="컨트롤러의-역할">컨트롤러의 역할</h3>
<ul>
<li>들어오는 응답을 가로챈다.</li>
<li>응답의 내용을 데이터 내부 체계로 변환시킨다.</li>
<li>추가의 처리를 위한 모델에 데이터를 보낸다.</li>
<li>모델로부터 처리된 데이터를 얻어와 렌더링을 위해 해당 데이터를 뷰로 전달한다.</li>
</ul>
<p><strong>스프링 MVC 다이어그램</strong>
<img src="/assets/images/dispatching-servlet-2d1d65483391b0f750b5826bea51750c.png" width="1770" height="814"></p>
<ul>
<li>여기서 발송 서블릿이 아키텍처에서 Front 컨트롤러의 역할을 수행한다.</li>
<li>위 MCV 다이어그램이 전형적인 MCV 컨트롤러 뿐만아니라 RESTful 컨트롤러에 해당된다. (약간만 다르다.)</li>
<li>전통적인 접근법으로 MVC 어플리케이션은 서비스 지향이 아니라서 뷰 리졸버를 통해 컨트롤러로부터 얻어낸 데이터를 기반으로 최종 뷰를 렌더링한다.</li>
<li>RESTful 어플리케이션은 서비스 지향으로 디자인되어서 원본 데이터(주로 JSON)을 반환한다.</li>
<li>이러한 어플리케이션이 어떠한 뷰 렌더링도 하지 않기 때문에, 뷰 리졸버가 존재하지 않는다.</li>
<li>그래서 컨트롤러가 일반적으로 직접 HTTP 응답을 통해 데이터를 전송할 것으로 기대한다.
<a href="https://www.baeldung.com/spring-controllers">출처</a></li>
</ul>
<h1 id="maven-dependencies">Maven Dependencies</h1>
<ul>
<li>Maven은 빌드 자동화 도구로 주로 자바 프로젝트에서 쓰인다.</li>
<li>스프링에서는 Maven이 의존성들을 구성하고 프로젝트를 빌드하는데 사용된다.</li>
<li>다음은 스프링 부트에서 스프링 MVC로 동작하기 위해서 Maven 의존성을 다뤄본다.</li>
</ul>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="스프링-부트-web-config">스프링 부트 Web Config</h1>
<ul>
<li>스프링 부트에서 어떻게 구성하는지 들여다보자.</li>
<li>클래서 경로에 thymeleaf 의존성을 추가했기 때문에, 이를 위한 어떤 @Beans도 구성할 필요가 없습니다.</li>
</ul>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>WebConfig에서 기본 설정 서블릿과 Greeting 객체와 오브젝트 매퍼를 위한 빈을 가능하도록 추가해준다.</li>
</ul>
<pre><code>@Bean
public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; enableDefaultServlet(){
	return factory -&gt; factory.setRegisterDefaultServlet(true);
}

@Bean
public Greeting greeting() {
	Greeting greeting = new Greeting();
	greeting.setMessage(&quot;Hello World !!&quot;);
	return greeting;
}

@Bean
public ObjectMapper objectMapper() {
return new ObejctMapper();
}
</code></pre>
<ul>
<li>예를들어, 만약 컨트롤러가 &quot;welcome&quot; 이름의 뷰를 반환하면, 뷰 리졸버는 템플릿 폴더 안에 &quot;welcome.html&quot;이라 불리는 페이지를 처리한다.</li>
<li>템플릿 폴더가 thymeleaf가 뷰를 찾도록 기본 설정된 폴더이다.</li>
</ul>
<h1 id="mvc-컨트롤러">MVC 컨트롤러</h1>
<ul>
<li>MVC 스타일의 컨트롤러를 구현하자</li>
<li>어떻게 ModelAndView 객체를 반환하는지 주목하자.</li>
<li>ModelAndView 객체는 모델 맵과 뷰 객체를 포함하고 둘다 뷰 리졸버에서 데이터 렌더링에 사용된다.</li>
</ul>
<pre><code>@Controller
@RequestMapping(value= &quot;/test&quot;)
public class TestController {
	@GetMapping
	public ModelAndView getTestData() {
		ModelAndView mv = new ModelAndView();
		mv.setViewName(&quot;welcome&quot;);
		mv.getModel().put(&quot;data&quot;, &quot;Welcome Home man&quot;);
		return mv;
	}
}
</code></pre>
<ul>
<li>
<p>여기까지 정확하게 구축한게 여기있다.</p>
</li>
<li>
<p>먼저 TestController라고 불리는 컨테이너를 만들고 그것을 &quot;/test&quot; 경로에 매핑했다.</p>
</li>
<li>
<p>클래스에서, ModelAndView 객체를 반환하는 메서드를 만들고</p>
</li>
<li>
<p>GET 요청을 통해서 메서드를 패밍하여 &quot;test&quot;로 끝나는 URL 호출이 발송 서블릿으로 라우팅되어 TestContoller의 getTestData 메서드로 전달됩니다.</p>
</li>
<li>
<p>물론 ModelAndView 객체에 추가로 몇몇 모델 데이터도 반환한다.</p>
</li>
<li>
<p>뷰 객체는 &quot;welcome&quot;으로 설정되었고 위에서 언급한대로, 뷰 리졸버가 템플릿 폴더 안에 &#x27;welcome.html&#x27;으로 불리는 페이지를 찾는다.</p>
</li>
</ul>
<h1 id="rest-컨트롤러">REST 컨트롤러</h1>
<ul>
<li>스프링 RESTful 어플리케이션 구축은 MVC어플리케이션의 것과 뷰리졸버와 모델 맵이 없다는 것 빼고는 같다.</li>
<li>API가 간단히 JSON과 같은 방식의 원본 데이터로 클라이언트에게 반환한다.</li>
<li>그래서 발송 서블릿이 뷰 리졸버를 우회하여 HTTP 응답 바디의 데이터를 바로 반환한다.</li>
<li>간단한 RESTful controller의 구현을 보자.</li>
</ul>
<pre><code>@RestContorller
public class Restcontroller {
	@GetMapping(value = &quot;/student/{studentId}&quot;)
	public Student getTestData(@PathVariable Integer studentId) {
		Student student = new Student();
		student.setName(&quot;Peter&quot;);
		student.setId(student.ID);
		return student;
	}
}
</code></pre></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/data">data</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/leetaehwan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Taehwan Lee. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>